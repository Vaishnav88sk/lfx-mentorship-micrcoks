#------------------- Global Variables (deploy-microcks-variables.sh) -------------------

#!/bin/bash

# Set your region
REGION="ap-south-1"

# Step 1: Get the default VPC ID
DEFAULT_VPC_ID=$(aws ec2 describe-vpcs \
  --region $REGION \
  --filters Name=isDefault,Values=true \
  --query "Vpcs[0].VpcId" \
  --output text)

# Check if the default VPC ID was fetched successfully
if [ "$DEFAULT_VPC_ID" == "None" ]; then
  echo "No default VPC found in region $REGION."
  exit 1
fi

echo "Default VPC ID: $DEFAULT_VPC_ID"

# Step 2: Get public subnet IDs from the default VPC
SUBNET_IDS=$(aws ec2 describe-subnets \
  --region $REGION \
  --filters Name=vpc-id,Values=$DEFAULT_VPC_ID Name=default-for-az,Values=true \
  --query "Subnets[*].SubnetId" \
  --output text)

# Check if any public subnets were found
if [ -z "$SUBNET_IDS" ]; then
  echo "No public subnets found in the default VPC."
  exit 1
fi

# Convert space-separated subnet IDs to comma-separated
SUBNET_IDS_COMMA=$(echo $SUBNET_IDS | tr ' ' ',')

echo "Public Subnet IDs: $SUBNET_IDS_COMMA"

# Step 3: Fetch the latest Aurora PostgreSQL engine version
LATEST_ENGINE_VERSION=$(aws rds describe-db-engine-versions \
  --region $REGION \
  --engine aurora-postgresql \
  --query "DBEngineVersions[0].EngineVersion" \
  --output text)

echo "Latest Aurora PostgreSQL Engine Version: $LATEST_ENGINE_VERSION"

# Step 4: Fetch default VPC security group ID
DEFAULT_SG_ID=$(aws ec2 describe-security-groups \
  --region $REGION \
  --filters Name=vpc-id,Values=$DEFAULT_VPC_ID Name=group-name,Values=default \
  --query "SecurityGroups[0].GroupId" \
  --output text)

echo "Default Security Group ID: $DEFAULT_SG_ID"


#------------------- Above in Shell script -------------------

# Set your AWS region
REGION="ap-south-1"
CLUSTER_NAME="microcks-cluster"

# Get latest supported Kubernetes version
LATEST_VERSION=$(aws eks describe-addon-versions \
  --region $REGION \
  --query "addons[?addonName=='kube-proxy'].addonVersions[].compatibilities[].clusterVersion" \
  --output text | tr '\t' '\n' | sort -uV | tail -n1)

# Get default VPC ID
DEFAULT_VPC_ID=$(aws ec2 describe-vpcs \
  --region $REGION \
  --filters Name=isDefault,Values=true \
  --query "Vpcs[0].VpcId" \
  --output text)

# Get public subnets from default VPC
PUBLIC_SUBNETS=$(aws ec2 describe-subnets \
  --region $REGION \
  --filters Name=vpc-id,Values=$DEFAULT_VPC_ID Name=default-for-az,Values=true \
  --query "Subnets[*].SubnetId" \
  --output text | tr '\t' ',')

# Echo for verification
echo "Region: $REGION"
echo "Kubernetes Version: $LATEST_VERSION"
echo "Default VPC ID: $DEFAULT_VPC_ID"
echo "Public Subnets: $PUBLIC_SUBNETS"

# Create EKS cluster
eksctl create cluster \
  --name $CLUSTER_NAME \
  --region $REGION \
  --version $LATEST_VERSION \
  --vpc-public-subnets $PUBLIC_SUBNETS \
  --nodegroup-name microcks-nodes \
  --node-type t3.medium \
  --nodes 2 \
  --nodes-min 1 \
  --nodes-max 3 \
  --managed

eksctl utils associate-iam-oidc-provider --region=$REGION --cluster=$CLUSTER_NAME --approve

eksctl update addon --name vpc-cni --cluster $CLUSTER_NAME --region $REGION

eksctl get cluster --name $CLUSTER_NAME

aws eks update-kubeconfig --name $CLUSTER_NAME --region $REGION

kubectl get nodes

#------------------- Above in Shell script -------------------

helm repo add microcks https://microcks.io/helm
helm repo update

aws rds create-db-subnet-group \
  --db-subnet-group-name microcks-subnet-group \
  --db-subnet-group-description "Subnet group for Microcks Aurora" \
  --subnet-ids subnet-01df6880678c3999a subnet-0fdbc0c54c4c75cac
  
  
aws rds create-db-cluster \
  --db-cluster-identifier microcks-db-cluster \
  --engine aurora-postgresql \
  --engine-version 15.10 \
  --master-username microcks \
  --master-user-password microcks123 \
  --vpc-security-group-ids sg-04c4a6a77fd165119 \
  --db-subnet-group-name microcks-subnet-group \
  --serverless-v2-scaling-configuration MinCapacity=0.5,MaxCapacity=2 \
  --backup-retention-period 7 \
  --enable-http-endpoint \
  --region ap-south-1
  
 aws rds create-db-instance \
  --db-instance-identifier microcks-db-instance \
  --db-cluster-identifier microcks-db-cluster \
  --engine aurora-postgresql \
  --db-instance-class db.serverless \
  --region ap-south-1

{
aws rds create-db-cluster   --db-cluster-identifier microcks-db-cluster   --engine aurora-postgresql   --master-username microcks   --master-user-password microcks123   --serverless-v2-scaling-configuration MinCapacity=0.5,MaxCapacity=2   --vpc-security-group-ids sg-0f0e1396259ce7331
}

aws rds describe-db-clusters --query "DBClusters[0].Endpoint" --output text

aws docdb create-db-cluster   --db-cluster-identifier microcks-docdb-cluster   --engine docdb   --master-username microcks   --master-user-password microcks123   --vpc-security-group-ids sg-04c4a6a77fd165119 

aws docdb describe-db-clusters --query "DBClusters[0].Endpoint" --output text

helm install microcks microcks/microcks   --namespace microcks   --create-namespace   --set microcks.db.external=true   --set microcks.db.mongo.connectionString="mongodb://microcks:microcks123@microcks-db-cluster.cluster-cza0gcu8ejq5.ap-south-1.rds.amazonaws.com:27017/microcks"   --set microcks.db.postgres.host=microcks-db-cluster.cluster-cza0gcu8ejq5.ap-south-1.rds.amazonaws.com   --set microcks.db.postgres.user=microcks   --set microcks.db.postgres.password=microcks123

eksctl create addon --name aws-ebs-csi-driver --cluster microcks-cluster --region ap-south-1

kubectl get pods -n microcks

kubectl apply -k "github.com/aws/eks-charts/stable/aws-load-balancer-controller/crds?ref=master"

kubectl apply -f https://github.com/kubernetes-sigs/aws-load-balancer-controller/releases/download/v2.12.0/v2_12_0_full.yaml

kubectl get deployment -n kube-system aws-load-balancer-controller




